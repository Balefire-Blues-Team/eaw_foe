UNI_dunk = {
	UNI_dunk_peacetime = {
		icon = GFX_decision_generic_ignite_civil_war
		days_remove = 50
		available = {
		}
		
		visible = {
				has_completed_focus = unity_start_4
		}
		days_re_enable = 50
		cost = 25

		ai_will_do = {
			factor = 20
		}

		complete_effect = {
			log = "[GetDateText]: [Root.GetName]: Decision UNI_dunk_p"
			add_equipment_to_stockpile = {
				type = dragon_equipment_0
				amount = 50
				producer = UNI
			}
			random_controlled_state = {
					limit = {
						state_population > 60
					}
					add_manpower = -60
				}
		}
	}
	
	UNI_dunk_wartime = {
		icon = GFX_decision_generic_ignite_civil_war
		days_remove = 10
		available = {
			has_war = yes
		}
		
		visible = {
				has_completed_focus = unity_start_4
		}
		days_re_enable = 10
		cost = 50

		ai_will_do = {
			factor = 1
		}

		complete_effect = {
			log = "[GetDateText]: [Root.GetName]: Decision UNI_dunk_w"
			add_equipment_to_stockpile = {
				type = dragon_equipment_0
				amount = 50
				producer = UNI
			}
			random_controlled_state = {
					limit = {
						state_population > 100
					}
					add_manpower = -100
				}
		}
	}
}

UNI_black_book = {
	UNI_whitetail_raid = {
		icon = border_war

		available = {
			797 = {
				is_owned_and_controlled_by = FROM
				any_neighbor_state = {
					is_fully_controlled_by = ROOT
					set_temp_variable = { var:attacker_state_temp = id }
					has_ROOT_at_least_1_div_in_current_state_scope = yes
					hidden_trigger = { NOT = { has_state_flag = border_incident_active } }
					is_impassable = no
				}
				NOT = { has_state_flag = border_incident_active }
				set_temp_variable = { var:defender_state_temp = id }
			}
			NOT = {
				has_non_aggression_pact_with = FROM
				has_guaranteed = FROM
			}
		}

		visible = {
			FROM = { exists = yes }
			NOT = { has_war_with = FROM }
			FROM = { has_not_initiated_border_incident_with_ROOT = yes }
			FROM = {
				NOT = {
					is_subject_of = ROOT
				}
				NOT = {
					is_in_faction_with = ROOT
				}
			}
			NOT = {
				is_subject_of = FROM
			}
			OR = {
				NOT = { has_border_war_with = FROM }
				any_state = {
					is_owned_and_controlled_by = FROM
					hidden_trigger = { NOT = { has_state_flag = border_incident_active } }
					is_impassable = no
					any_neighbor_state = {
						hidden_trigger = { NOT = { has_state_flag = border_incident_active } }
						is_fully_controlled_by = ROOT
						is_impassable = no
					}
				}
			}
		}

		target_trigger = {
			original_tag = UNI
			FROM = { original_tag = SPV }
		}

		highlight_states = {
			OR = {
				state = FROM.defender_state_vs_@ROOT
				AND = {
					is_owned_and_controlled_by = FROM
					hidden_trigger = { NOT = { has_state_flag = border_incident_active } }
					is_impassable = no
					any_neighbor_state = {
						hidden_trigger = { NOT = { has_state_flag = border_incident_active } }
						has_ROOT_at_least_1_div_in_current_state_scope = yes
						is_fully_controlled_by = ROOT
						is_impassable = no
					}
				}
			}
		}

		ai_will_do = {
			base = 20
			modifier = {
				factor = 0
				has_war = yes
			}
		}

		cost = 50

		fire_only_once = no

		days_remove = 50
		days_re_enable = 45

		war_with_target_on_remove = yes

		complete_effect = {
			if = {
				limit = { has_global_flag = debug_logs }
				log = "[GetDateText]: [Root.GetName] border_conflict_initiate_incident (decision) complete entered"
			}
			hidden_effect = {
				797 = {
					limit = {
						is_owned_and_controlled_by = FROM
						hidden_trigger = { NOT = { has_state_flag = border_incident_active } }
						is_impassable = no
						any_neighbor_state = {
							hidden_trigger = { NOT = { has_state_flag = border_incident_active } }
							has_ROOT_at_least_1_div_in_current_state_scope = yes
							is_fully_controlled_by = ROOT
							is_impassable = no
						}
					}
					save_event_target_as = defender_state
					set_variable = { FROM.defender_state_vs_@ROOT = id }
					set_temp_variable = { defender_state_temp = id }
					set_state_flag = border_incident_active
				}
				random_state = {
					limit = {
						is_fully_controlled_by = ROOT
						hidden_trigger = { NOT = { has_state_flag = border_incident_active } }
						has_ROOT_at_least_1_div_in_current_state_scope = yes
						is_impassable = no
						any_neighbor_state = {
							state = var:FROM.defender_state_vs_@ROOT
							is_impassable = no
						}
					}
					save_event_target_as = attacker_state
					set_variable = { FROM.attacker_state_vs_@ROOT = id }
					set_temp_variable = { attacker_state_temp = id }
					set_state_flag = border_incident_active
				}
			}
			custom_effect_tooltip = border_incident_delay_until_new_incident_180
			FROM = {
				country_event = { id = border_incident_defender_warning.1 hours = 1 }
				activate_targeted_decision = { target = ROOT decision = border_conflict_incident_warning_defender }
			}
			if = {
				limit = { has_global_flag = debug_logs }
				log = "[GetDateText]: [Root.GetName] border_conflict_initiate_incident (decision) complete exited"
			}
		}
		remove_effect = {
			if = {
				limit = { has_global_flag = debug_logs }
				log = "[GetDateText]: [Root.GetName] border_conflict_initiate_incident (decision) remove entered"
			}
			hidden_effect = {
				var:FROM.defender_state_vs_@ROOT = {
					save_event_target_as = defender_state
				}
				var:FROM.attacker_state_vs_@ROOT = {
					save_event_target_as = attacker_state
				}
				797 = {
					limit = {
						is_owned_and_controlled_by = FROM
						hidden_trigger = { NOT = { has_state_flag = border_incident_active } }
						any_neighbor_state = {
							is_fully_controlled_by = ROOT
							has_ROOT_at_least_1_div_in_current_state_scope = yes
							hidden_trigger = { NOT = { has_state_flag = border_incident_active } }
						}
					}
					set_temp_variable = { defender_state_temp = id }
				}
				random_state = {
					limit = {
						is_fully_controlled_by = ROOT
						hidden_trigger = { NOT = { has_state_flag = border_incident_active } }
						has_ROOT_at_least_1_div_in_current_state_scope = yes
						any_neighbor_state = {
							state = var:FROM.defender_state_vs_@ROOT
						}
					}
					set_temp_variable = { attacker_state_temp = id }
				}
			}
			activate_targeted_decision = { target = FROM decision = escalate_incident_to_border_conflict }
			if = {
				limit = { has_global_flag = debug_logs }
				log = "[GetDateText]: [Root.GetName] border_conflict_initiate_incident (decision) remove exited"
			}
		}
	}

	#Mission for defender warning that a conflict with FROM is coming
	border_conflict_incident_warning_defender = {

		icon = border_war

		allowed = { always = no } #Activated from effect

		available = {
			hidden_trigger = { always = no }
		}

		highlight_states = {
			OR = {
				state = var:defender_state_temp
				state = var:ROOT.defender_state_vs_@FROM
			}
		}

		war_with_target_on_timeout = yes
		ai_will_do = {
			base = 0
			modifier = {

			}
		}

		days_mission_timeout = @border_incident_escalation_countdown

		fire_only_once = yes

		is_good = no

		timeout_effect = {
			if = {
				limit = { has_global_flag = debug_logs }
				log = "[GetDateText]: [Root.GetName] border_conflict_incident_warning_defender (decision) timeout entered"
			}
			custom_effect_tooltip = escalation_possible_tooltip_for_defender
			custom_effect_tooltip = effects_if_border_conflict_is_lost
			effect_tooltip = {
				add_political_power = -10
				var:ROOT.defender_state_vs_@FROM = { FROM = { transfer_state = PREV } }
			}
			hidden_effect = {
				remove_targeted_decision = { target = FROM decision = border_conflict_incident_warning_defender }
				activate_targeted_decision = { target = FROM decision = border_conflict_escalation_warning_defender }
			}
			if = {
				limit = { has_global_flag = debug_logs }
				log = "[GetDateText]: [Root.GetName] border_conflict_incident_warning_defender (decision) timeout exited"
			}
		}
	}

	#Mission for defender warning FROM can escalate to war at any point is coming
	border_conflict_escalation_warning_defender = {

		icon = border_war

		allowed = { always = no } #Activated from effect

		available = {
			hidden_trigger = { always = no }
		}

		highlight_states = {
			OR = {
				state = var:defender_state_temp
				state = var:ROOT.defender_state_vs_@FROM
			}
		}

		war_with_target_on_timeout = yes
		ai_will_do = {
			base = 0
			modifier = {

			}
		}

		days_mission_timeout = @border_conflict_incident_forgotten_timer

		fire_only_once = yes

		is_good = no

		timeout_effect = {
			# No debug as it does literally nothing
			custom_effect_tooltip = from_cannot_escalate
			custom_effect_tooltip = effects_if_border_conflict_is_lost
			effect_tooltip = {
				add_political_power = -10
				var:ROOT.defender_state_vs_@FROM = { FROM = { transfer_state = PREV } }
			}
		}
	}

	#Mission for attacker to escalate or incident is forgotten
	#Decision to escalate incident on border with FROM to border conflict
	escalate_incident_to_border_conflict = {

		icon = border_war

		allowed = { always = no } #Activated from effect

		available = {
			var:FROM.attacker_state_vs_@ROOT = {
				is_fully_controlled_by = ROOT
			}
			divisions_in_border_state = {
				state = var:FROM.attacker_state_vs_@ROOT
				border_state = var:FROM.defender_state_vs_@ROOT
				size > 0
			}
		}

		highlight_states = {
			state = var:FROM.attacker_state_vs_@ROOT
		}

		ai_will_do = {
			base = 20
			modifier = {
				factor = 0
				has_war = yes
			}
		}

		cancel_trigger = {
			OR = {
				is_in_faction_with = FROM
				var:FROM.defender_state_vs_@ROOT = {
					owner = {
						NOT = {
							original_tag = MOJ
						}
					}
				}
			}
		}

		selectable_mission = yes

		fire_only_once = yes #Reactivation handled in effect

		days_mission_timeout = @border_conflict_incident_forgotten_timer

		timeout_effect = {
			if = {
				limit = { has_global_flag = debug_logs }
				log = "[GetDateText]: [Root.GetName] escalate_incident_to_border_conflict (decision) timeout entered"
			}
			custom_effect_tooltip = border_incident_delay_until_new_incident_120
			hidden_effect = {
				FROM = { remove_targeted_decision = { target = ROOT decision = border_conflict_escalation_warning_defender } }
				FROM = {
					var:attacker_state_vs_@ROOT = {
						clr_state_flag = border_incident_active
					}
					var:defender_state_vs_@ROOT = {
						clr_state_flag = border_incident_active
					}
					clear_variable = attacker_state_vs_@ROOT
					clear_variable = defender_state_vs_@ROOT
				}
			}
			if = {
				limit = { has_global_flag = debug_logs }
				log = "[GetDateText]: [Root.GetName] escalate_incident_to_border_conflict (decision) timeout exited"
			}
		}

		complete_effect = {
			if = {
				limit = { has_global_flag = debug_logs }
				log = "[GetDateText]: [Root.GetName] escalate_incident_to_border_conflict (decision) complete entered"
			}
			start_border_war = {
				change_state_after_war = no
				#attacker_modifier = 0.15
				attacker = {
					state = var:FROM.attacker_state_vs_@ROOT
					num_provinces = 4
					on_win = border_conflict_won_attacker.1
					on_lose = border_conflict_lost_attacker.1
					on_cancel = border_conflict_canceled_attacker.1
				}

				defender = {
					state = var:FROM.defender_state_vs_@ROOT
					num_provinces = 1
					on_win = border_conflict_won_defender.1
					on_lose = border_conflict_lost_defender.1
					on_cancel = border_conflict_canceled_defender.1
				}
			}
			FROM = {
				activate_targeted_decision = { target = ROOT decision = border_conflict_escalate_conflict }
				activate_targeted_decision = { target = ROOT decision = border_conflict_time_until_cancelled }
			}
			activate_targeted_decision = { target = FROM decision = border_conflict_escalate_conflict }
			activate_targeted_decision = { target = FROM decision = border_conflict_time_until_cancelled }
			if = {
				limit = { has_global_flag = debug_logs }
				log = "[GetDateText]: [Root.GetName] escalate_incident_to_border_conflict (decision) complete exited"
			}
		}
	}

	#Mission for attacker to win border war against FROM in X days
	border_conflict_time_until_cancelled = {

		icon = border_war

		allowed = { always = no } #Activated from effect

		available = {
			var:FROM.defender_state_vs_@ROOT = { has_border_war = no }
			var:FROM.attacker_state_vs_@ROOT = { has_border_war = no }
		}

		highlight_states = {
			OR = {
				state = var:defender_state_temp
				state = var:FROM.defender_state_vs_@ROOT
			}
		}

		ai_will_do = {
			base = 0
			modifier = {

			}
		}

		days_mission_timeout = @border_conflict_time_until_cancelled
		is_good = no

		fire_only_once = yes #Reactivation handled in effect

		complete_effect = {

		}

		timeout_effect = {
			if = {
				limit = { has_global_flag = debug_logs }
				log = "[GetDateText]: [Root.GetName] border_conflict_time_until_cancelled (decision) timeout entered"
			}
			if = {
				limit = { is_border_conflict_defender_vs_FROM = yes }
				cancel_border_war = {
					defender = var:defender_state_vs_@FROM
					attacker = var:attacker_state_vs_@FROM
				}
			}
			else = {
				cancel_border_war = {
					defender = var:FROM.defender_state_vs_@ROOT
					attacker = var:FROM.attacker_state_vs_@ROOT
				}
			}
			hidden_effect = {
				remove_targeted_decision = { target = FROM decision = border_conflict_escalate_conflict }
			}
			if = {
				limit = { has_global_flag = debug_logs }
				log = "[GetDateText]: [Root.GetName] border_conflict_time_until_cancelled (decision) timeout exited"
			}
		}
	}

	#Decision to escalate conflict further
	border_conflict_escalate_conflict = {

		icon = decision_generic_ignite_civil_war

		allowed = { always = no } #Activated from effect

		visible = {
			has_border_war_with = FROM
		}

		highlight_states = {
			OR = {
				state = var:FROM.attacker_state_vs_@ROOT
				state = var:ROOT.defender_state_vs_@FROM
			}
		}

		cost = 30

		ai_will_do = {
			base = 30
			modifier = {
				factor = 0
				has_war = yes
			}
		}

		fire_only_once = yes #Reactivation handled in effect

		complete_effect = {
			if = {
				limit = { has_global_flag = debug_logs }
				log = "[GetDateText]: [Root.GetName] border_conflict_escalate_conflict (decision) complete entered"
			}
			if = {
				limit = { is_border_conflict_defender_vs_FROM = yes }
				set_border_war_data = {
					attacker = var:ROOT.defender_state_vs_@FROM
					defender = var:ROOT.defender_state_vs_@FROM
					defender_modifier = 0.5
					#attacker_modifier = 0.5
					combat_width = 100
				}
			}
			else = {
				set_border_war_data = {
					attacker = var:FROM.defender_state_vs_@ROOT
					defender = var:FROM.defender_state_vs_@ROOT
					#defender_modifier = 0.5
					attacker_modifier = 0.5
					combat_width = 100
				}
			}
			FROM = {
				set_country_flag = {
					flag = border_conflict_escalate_to_war_cooldown_@ROOT
					days = @border_conflict_escalate_to_war_countdown
					value = 1
				}
				remove_targeted_decision = { target = ROOT decision = border_conflict_escalate_conflict }
			}
			set_country_flag = {
				flag = border_conflict_escalate_to_war_cooldown_@FROM
				days = @border_conflict_escalate_to_war_countdown
				value = 1
			}
			custom_effect_tooltip = in_45_days
			activate_targeted_decision = { target = FROM decision = border_conflict_escalate_to_war }
			if = {
				limit = { has_global_flag = debug_logs }
				log = "[GetDateText]: [Root.GetName] border_conflict_escalate_conflict (decision) complete exited"
			}
		}
	}

	#Decision to escalate conflict further
	border_conflict_escalate_to_war = {

		icon = decision_generic_ignite_civil_war

		allowed = { always = no } #Activated from effect

		visible = {
			NOT = { has_country_flag = border_conflict_escalate_to_war_cooldown_@FROM }
			has_border_war_with = FROM
		}

		highlight_states = {
			OR = {
				state = var:FROM.defender_state_vs_@ROOT
				state = var:ROOT.attacker_state_vs_@FROM
			}
		}

		cost = 30

		ai_will_do = {
			base = 0
			modifier = {

			}
		}

		days_remove = 15

		fire_only_once = yes #Reactivation handled in effect

		war_with_target_on_remove = yes

		complete_effect = {
			if = {
				limit = { has_global_flag = debug_logs }
				log = "[GetDateText]: [Root.GetName] border_conflict_escalate_to_war (decision) complete entered"
			}
			if = {
				limit = { is_border_conflict_defender_vs_FROM = yes }
				var:ROOT.defender_state_vs_@FROM = { save_event_target_as = their_state }
				var:ROOT.attacker_state_vs_@FROM = { save_event_target_as = our_state }
			}
			else = {
				var:FROM.defender_state_vs_@ROOT = { save_event_target_as = our_state }
				var:FROM.attacker_state_vs_@ROOT = { save_event_target_as = their_state }
			}
			FROM = {
				country_event = { id = border_conflict_escalate_to_war.1 }
				hidden_effect = {
					remove_targeted_decision = { target = ROOT decision = border_conflict_escalate_to_war }
				}
			}
			if = {
				limit = { has_global_flag = debug_logs }
				log = "[GetDateText]: [Root.GetName] border_conflict_escalate_to_war (decision) complete exited"
			}
		}

		remove_effect = {
			if = {
				limit = { has_global_flag = debug_logs }
				log = "[GetDateText]: [Root.GetName] border_conflict_escalate_to_war (decision) remove entered"
			}
			cancel_border_war = {
				dont_fire_events = yes
				defender = var:FROM.defender_state_vs_@ROOT
				attacker = var:FROM.attacker_state_vs_@ROOT
			}
			if = {
				limit = {
					NOT = { has_war_with = FROM }
				}
				declare_war_on = { target = FROM type = annex_everything }
			}
			if = {
				limit = { is_border_conflict_defender_vs_FROM = yes }
				var:attacker_state_vs_@FROM = {
					clr_state_flag = border_incident_active
				}
				var:defender_state_vs_@FROM = {
					clr_state_flag = border_incident_active
				}
				clear_variable = attacker_state_vs_@FROM
				clear_variable = defender_state_vs_@FROM
			}
			else = {
				FROM = {
					var:attacker_state_vs_@ROOT = {
						clr_state_flag = border_incident_active
					}
					var:defender_state_vs_@ROOT = {
						clr_state_flag = border_incident_active
					}
					clear_variable = attacker_state_vs_@ROOT
					clear_variable = defender_state_vs_@ROOT
				}
			}
			if = {
				limit = { has_global_flag = debug_logs }
				log = "[GetDateText]: [Root.GetName] border_conflict_escalate_to_war (decision) remove exited"
			}
		}
	}

	#Decision to back down from conflict
	border_conflict_back_out_of_conflict = {

		allowed = { always = no } #Activated from effect

		visible = {
			has_border_war_with = FROM
		}

		highlight_states = {
			OR = {
				state = var:FROM.attacker_state_vs_@ROOT
				state = var:ROOT.defender_state_vs_@FROM
			}
		}

		ai_will_do = {
			base = 0
			modifier = {

			}
		}

		fire_only_once = yes #Reactivation handled in effect

		complete_effect = {
			if = {
				limit = { has_global_flag = debug_logs }
				log = "[GetDateText]: [Root.GetName] border_conflict_back_out_of_conflict (decision) complete entered"
			}
			if = {
				limit = { is_border_conflict_defender_vs_FROM = yes }
				finalize_border_war = {
					attacker_win = yes
					attacker = ROOT.attacker_state_vs_@FROM
					defender = ROOT.attacker_state_vs_@FROM
				}
			}
			else = {
				finalize_border_war = {
					attacker = FROM.attacker_state_vs_@ROOT
					defender = FROM.attacker_state_vs_@ROOT
					defender_win = yes
				}
			}
			if = {
				limit = { has_global_flag = debug_logs }
				log = "[GetDateText]: [Root.GetName] border_conflict_back_out_of_conflict (decision) complete exited"
			}
		}
	}
	
}